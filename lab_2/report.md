
# Отчет по лабораторной работе №2
# Основы программирования в R

**Дата:** 2025-10-08  
**Семестр:** 2 курс, 1 полугодие (3 семестр)  
**Группа:** ПИН-б-о-24-1  
**Дисциплина:** Технологии программирования  
**Студент:** Лаврентьев Аврам Петрович

---

## Цель работы
Познакомиться с основными парадигмами программирования в языке R, изучить их принципы и реализовать практические задания для закрепления навыков.

---

## Теоретическая часть

Каждая парадигма программирования задает свой подход к организации кода и обработке данных.  
В ходе лабораторной работы рассматривались следующие принципы:

| Парадигма | Ключевая идея |
|------------|----------------|
| Императивная | Программа как последовательность команд, изменяющих состояние памяти |
| Структурная | Использование блоков, циклов, ветвлений вместо goto |
| ООП | Представление программы как системы объектов с состоянием и поведением |
| Векторная | Одновременная обработка целых наборов данных |
| Функциональная | Применение функций высшего порядка и конвейеров |
| Грамотное программирование | Использование R Markdown для репродуктивных отчетов |
| Параллельная | Распараллеливание вычислений для ускорения работы |

---

## Практическая часть

### 1. Императивное (процедурное) программирование

**Задача:** Напишите программу, рассчитывающую площадь трех фигур: квадрат, прямоугольник и круг. На 
входе программа запрашивает введение данных о фигурах (для квадрата – сторона, круг – радиус, 
прямоугольник – две стороны). На выходе программа указывает общую площадь. 

```r
square_area <- function(a) a^2
rectangle_area <- function(a, b) a * b
circle_area <- function(r) pi * r^2

a <- 5; b <- 5; r <- 5
total_area <- square_area(a) + rectangle_area(a, b) + circle_area(r)
print(paste("Общая площадь:", total_area))
```
**Результат:**
```
[1] "Общая площадь: 128.539816339745"
```
В императивном подходе программа представляет собой последовательность команд, которые явно изменяют состояние программы. Здесь мы определяем функции для вычисления площадей, затем последовательно вычисляем и суммируем результаты, сохраняя промежуточные значения в переменных.

**Контрольные вопросы:**

1. Особенности процедурного программирования
Процедурное программирование — это парадигма, в которой программа строится как последовательность команд,
 сгруппированных в процедуры (функции).
Основные особенности:
Программа выполняется сверху вниз
Используются процедуры и функции для повторного использования кода
Активно применяются переменные
Основной акцент — на алгоритме, а не на данных
Широко используются операторы:
присваивания
ветвления (if)
циклы (for, while)

2. Линейная программа
Линейная программа — это программа без:
ветвлений (if)
циклов (for, while)
Все команды выполняются строго по порядку, одна за другой.
3. Понятия: переменная, процедура, функция

Переменная  — это именованная область памяти, в которой хранится значение.


Процедура — это подпрограмма, выполняющая действия, не обязательно возвращающая значение.
В R роль процедур часто выполняют функции с побочными эффектами (например, print()).

Функция — это подпрограмма, возвращающая значение.

4. Безусловный оператор — оператор, который выполняется всегда, без проверки условий.

Примеры:

оператор присваивания <-

вызов функции

оператор перехода (goto в старых языках)

---

### 2. Структурное программирование

**Задача:** [Вариант 20] рассчитать площадь заданных фигур (трапеция, прямоугольник, параллелограмм).

```r
get_area <- function(shape) {
  if (shape == "трапеция") {
    side <- as.numeric(readline("Введите сторону трапеции: "))
    return(side^2)
  } else if (shape == "прямоугольник") {
    a <- as.numeric(readline("Введите сторону a: "))
    b <- as.numeric(readline("Введите сторону b: "))
    return(a*b)
  } else if (shape == "параллелограмм") {
    a <- as.numeric(readline("Введите сторону a: "))
    h <- as.numeric(readline("Введите высоту h: "))
    return(a*h)
  } else {
    return(NA)
  }
}
```
**Задача**:Написать программу вычисляющую площадь неправильного 
многоугольника. Многоугольник на плоскости задается целочисленными координатами своих 
N вершин в декартовой системе. Стороны многоугольника не соприкасаются (за исключением 
соседних - в вершинах) и не пересекаются. Программа в первой строке должна принимать 
число N – количество вершин многоугольника, в последующих N строках – координаты 
соответствующих вершин (вершины задаются в последовательности против часовой стрелки). 
На выход программа должна выдавать площадь фигуры. 

```r
calculate_polygon_area <- function() {
  # Считываем количество вершин
  n <- as.integer(readline(prompt = "Введите количество вершин многоугольника (N): "))
  
  # Проверка корректности введенного количества вершин
  if (is.na(n) || n < 3) {
    cat("ОШИБКА: Многоугольник должен иметь как минимум 3 вершины.\n")
    return()
  }
  
  # Инициализация векторов для координат
  x_coords <- numeric(n)
  y_coords <- numeric(n)
  
  # Считываем координаты вершин
  cat("Введите координаты вершин в порядке против часовой стрелки:\n")
  for (i in 1:n) {
    coords <- readline(prompt = paste("Вершина", i, "(x y): "))
    coords_split <- strsplit(coords, " ")[[1]]
    
    # Проверка корректности введенных координат
    if (length(coords_split) != 2) {
      cat("ОШИБКА: Неверный формат координат. Используйте: x y\n")
      return()
    }
    
    x_coords[i] <- as.numeric(coords_split[1])
    y_coords[i] <- as.numeric(coords_split[2])
    
    # Проверка на числовые значения
    if (is.na(x_coords[i]) || is.na(y_coords[i])) {
      cat("ОШИБКА: Координаты должны быть числами.\n")
      return()
    }
  }
 ```
Структурное программирование исключает использование оператора goto и основывается на трех базовых структурах: последовательность, ветвление и циклы. В данном примере используется ветвление (if-else) для организации логики программы в зависимости от выбора пользователя.

**Контрольные вопросы:**

1. Особенности структурного программирования
Структурное программирование — это метод программирования, основанный на чёткой структуре программы без неуправляемых переходов.

Основные особенности:
Отказ от оператора goto,
Программа строится из блоков,
Используются три базовые управляющие конструкции:

последовательность

ветвление (if, if else)

цикл (for, while, repeat)

Повышается:

читаемость кода

надёжность

удобство сопровождения


2. Теорема Бёма – Якопини

Теорема Бёма – Якопини утверждает:

Любую вычислимую программу можно записать, используя только три управляющие структуры:

**последовательность**

**ветвление**

**цикл**
 
Значение теоремы:

доказывает, что goto не нужен
, является теоретической основой структурного программирования,позволяет писать корректные и понятные программы

3. Пропуск итерации и досрочный выход из цикла
Пропуск итерации

Позволяет пропустить текущий шаг цикла и перейти к следующему.

В R используется оператор next

Досрочный выход из цикла:

Полное завершение цикла до окончания всех итераций.

В R используется оператор break


**Вопросы для поиска и письменного ответа:**
```
        1. Цикл с постусловием
        Цикл с постусловием — это цикл, в котором:
        условие проверяется после выполнения тела цикла
        тело выполняется минимум один раз
        В R используется цикл repeat
        2. Совместный цикл
        Совместный цикл — это цикл, в котором:
        используется несколько управляющих переменных
        несколько условий изменяются одновременно
        3. Вложенные циклы
        Вложенные циклы — это циклы, расположенные внутри других циклов.
        Особенности:
        внутренний цикл полностью выполняется для каждой итерации внешнего
        часто используются для работы с таблицами, матрицами
        4. Принцип проектирования программ «сверху-вниз»
        Принцип «сверху-вниз» — это метод проектирования, при котором:
        задача разбивается на крупные подзадачи
        каждая подзадача далее детализируется
        реализация идёт от общего к частному
        Этапы:
        Определение основной задачи
        Разбиение на функции
        Детализация алгоритмов
        Реализация и тестирование
```

---

### 3. Объектно-ориентированное программирование

**Задача:** Создайте дженерик, принимающий вектор, содержащий параметры фигуры 
и вычисляющий ее площадь. Для разных фигур создайте разные классы. В качестве метода по 
умолчанию дженерик должен выводить сообщение о невозможности обработки данных. 
```r
area <- function(x, ...) {
  UseMethod("area")
}

# Метод по умолчанию
area.default <- function(x, ...) {
  warning("Невозможно обработать данные: неподдерживаемый тип фигуры")
  NA
}

# Метод для круга (один параметр - радиус)
area.circle <- function(x, ...) {
  if(length(x) != 1 || !is.numeric(x) || x <= 0) {
    warning("Для круга требуется один положительный числовой параметр (радиус)")
    return(NA)
  }
  pi * x^2
}
```
**Задача:** Создайте генератор класса Микроволновая печь. В качестве данных класс 
должен содержать сведения о мощности печи (Вт) и о состоянии дверцы (открыта или 
закрыта). Данный класс должен обладать методами открыть и закрыть дверь микроволновки, 
а также методом, отвечающим за приготовление пищи. Метод, отвечающий за приготовление 
пищи, должен вводить систему в бездействие (используется Sys.sleep) на определенное 
количество времени (которое зависит от мощности печи) и после выводить сообщение о 
готовности пищи. 
```r
# Конструктор класса Микроволновая печь
microwave_oven <- function(power = 800, door_open = FALSE) {
  # Проверка корректности мощности
  if (!is.numeric(power) || power <= 0) {
    stop("Мощность должна быть положительным числом")
  }
  
  # Проверка корректности состояния дверцы
  if (!is.logical(door_open)) {
    stop("Состояние дверцы должно быть логическим значением (TRUE/FALSE)")
  }
  
  structure(
    list(
      power = power,
      door_open = door_open
    ),
    class = "microwave_oven"
  )
}

# Метод для открытия дверцы
open_door <- function(x) {
  UseMethod("open_door")
}

open_door.microwave_oven <- function(x) {
  if (!x$door_open) {
    x$door_open <- TRUE
    message("Дверца микроволновки открыта")
  } else {
    message("Дверца уже открыта")
  }
  return(x)
}

# Метод для закрытия дверцы
close_door <- function(x) {
  UseMethod("close_door")
}
```
**Задача:** Создайте класс копилка. Описание структуры классы выполните из своего 
понимания копилки. 
```r
piggy_bank <- function(capacity = 1000, current_amount = 0, material = "керамика", broken = FALSE) {
  # Проверка корректности параметров
  if (!is.numeric(capacity) || capacity <= 0) {
    stop("Вместимость должна быть положительным числом")
  }
  
  if (!is.numeric(current_amount) || current_amount < 0) {
    stop("Текущая сумма должна быть неотрицательным числом")
  }
  
  if (current_amount > capacity) {
    stop("Текущая сумма не может превышать вместимость копилки")
  }
  
  if (!is.logical(broken)) {
    stop("Статус 'broken' должен быть логическим значением")
  }
  
  structure(
    list(
      capacity = capacity,
      current_amount = current_amount,
      material = material,
      broken = broken,
      creation_date = Sys.Date()
    ),
    class = "piggy_bank"
  )
}
```
ООП позволяет организовать код вокруг объектов, которые объединяют данные и методы. В R используется система R6 для создания классов. Здесь мы создаем иерархию классов фигур с общим родительским классом Figure и переопределяем метод area() в дочерних классах.

**Контрольные вопросы:**
1. Принципы ООП по Алану Кею
```
Алан Кей — создатель концепции объектно-ориентированного программирования. Его исходные идеи отличаются от «классического» ООП из учебников.
Основные принципы по Алану Кею:
Всё является объектами
Объекты взаимодействуют путём передачи сообщений
У каждого объекта есть собственное состояние (память)
Объект сам определяет, как обрабатывать сообщение
Объекты могут быть независимыми и автономными
 Главное: не классы, а взаимодействие объектов.
```
2. Механизмы ООП
```
Механизмы ООП — это технические средства реализации принципов ООП.
Основные механизмы:
Инкапсуляция — сокрытие данных и реализаций
Наследование — создание новых классов на основе существующих
Полиморфизм — один интерфейс, разные реализации
Абстракция — выделение значимых характеристик
```
3. Основные понятия ООП
```
Понятие-Определение
Класс-Шаблон (описание) объекта
Объект-Экземпляр класса
Поле (свойство)-Переменная внутри объекта
Метод-Функция внутри класса
Сообщение-Вызов метода объекта
Интерфейс-Набор доступных методов
```
4. Создание и назначение дженериков
```
Дженерик (generic function) — это функция, которая:
определяет общий интерфейс
выбирает реализацию в зависимости от типа объекта
В R это основа полиморфизма.
----------------------------------------------------
Создание дженерика :
print_area <- function(x) {
  UseMethod("print_area")
}
----------------------------------------------------
Назначение дженериков:
реализация полиморфизма
единый интерфейс для разных классов
расширяемость программ
```
5. Создание класса в R6
```
R6 — это современная реализация классического ООП в R (с изменяемыми объектами).

Создание класса:
library(R6)

Person <- R6Class(
  classname = "Person",
  public = list(
    name = NULL,
    age = NULL,

    initialize = function(name, age) {
      self$name <- name
      self$age <- age
    },

    greet = function() {
      cat("Привет, меня зовут", self$name, "\n")
    }
  )
)

Создание объекта:
p1 <- Person$new("Анна", 20)
p1$greet()
```

6. Структура класса в R6
```
Класс R6 состоит из чётко определённых частей.

Основные элементы структуры класса R6:
ClassName <- R6Class(
  classname = "ClassName",

  public = list(
    # публичные поля
    # публичные методы
  ),

  private = list(
    # приватные поля
    # приватные методы
  ),

  active = list(
    # активные поля (геттеры/сеттеры)
  ),

  inherit = ParentClass
)

Назначение разделов:
Раздел-Назначение
public-Доступно извне
private-Доступно только внутри класса
active-Контролируемый доступ к данным
initialize-Конструктор
inherit-Наследование
```
---

### 4. Векторное программирование
**Задача:** В векторе my_vector отберите только те наблюдения, которые отклоняются от среднего 
меньше, чем на одно стандартное отклонение. Сохраните эти наблюдения в новую 
переменную my_vector2. При этом исходный вектор оставьте без изменений. 
```r
my_vector <- c(21,18,21,19,25,20,17,17,18,22,17,18,18,19,19,27,21,20,24,17,
               15,24,24,29,19,14,21,17,19,18,18,20,21,21,19,17,21,13,17,13,
               23,15,23,24,16,17,25,24,22)

mean_v <- mean(my_vector)
sd_v <- sd(my_vector)
my_vector2 <- my_vector[abs(my_vector - mean_v) < sd_v]
my_vector2
```
**Задача:**  Напишите функцию get_negative_values, которая получает на вход dataframe 
произвольного размера. Функция должна для каждой переменной в данных проверять, есть ли 
в ней отрицательные значения. Если в переменной отрицательных значений нет, то эта 
переменная нас не интересует, для всех переменных, в которых есть отрицательные значения 
мы сохраним их в виде списка или матрицы, если число элементов будет одинаковым в каждой 
переменной (смотри пример работы функции). 
```r
get_negative_values <- function(df) {
  # Создаем пустой список для хранения результатов
  result_list <- list()
  
  # Перебираем все столбцы dataframe
  for (col_name in names(df)) {
    # Получаем столбец
    column <- df[[col_name]]
    
    # Отбираем только отрицательные значения (исключая NA)
    negative_values <- column[!is.na(column) & column < 0]
    
    # Если в столбце есть отрицательные значения, добавляем их в результат
    if (length(negative_values) > 0) {
      result_list[[col_name]] <- negative_values
    }
  }
  
  # Проверяем, можно ли преобразовать в матрицу
  # Для этого все векторы в списке должны быть одинаковой длины
  if (length(result_list) > 0) {
    lengths <- sapply(result_list, length)
    
    # Если все векторы одинаковой длины, преобразуем в матрицу
    if (length(unique(lengths)) == 1 && all(lengths > 0)) {
      # Создаем матрицу, где каждый столбец - это вектор отрицательных значений
      result_matrix <- matrix(unlist(result_list), 
                              nrow = lengths[1], 
                              ncol = length(result_list),
                              byrow = FALSE)
      
      # Устанавливаем имена столбцов
      colnames(result_matrix) <- names(result_list)
      
      return(result_matrix)
    }
  }
  
  # Если матрицу создать нельзя или список пуст, возвращаем список
  return(result_list)
}
```
Векторное программирование в R позволяет работать с целыми векторами данных без использования явных циклов. Операции применяются ко всем элементам вектора одновременно. В примере мы фильтруем вектор, оставляя только значения, которые отклоняются от среднего не более чем на одно стандартное отклонение.

**Контрольные вопросы:**
1. Векторизация
```
Векторизация — это способность языка R выполнять операции сразу над целыми векторами, без явного использования циклов.
Суть векторизации:
одна операция применяется ко всем элементам
код короче и понятнее
выполнение быстрее, чем в циклах
Пример без векторизации (цикл):
x <- c(1, 2, 3)
y <- numeric(length(x))

for (i in 1:length(x)) {
  y[i] <- x[i] * 2
}

Векторизованный вариант:
y <- x * 2
```
2. Основные объекты языка R
```
Язык R работает с объектами разных типов.

Основные объекты:
Объект-Описание
ВекторОдномерный набор однотипных данных
Матрица-Двумерный вектор
Массив-Многомерная структура
Список (list)-Набор разнородных объектов
Фактор (factor)-Категориальные данные
Таблица данных (data.frame)-Табличные данные
Функция-Объект, выполняющий действия
```
3. Создание собственных функций
```
В R функции создаются с помощью ключевого слова function.

Общая форма:
имя <- function(параметры) {
  тело функции
  return(результат)
}

Пример функции:
square <- function(x) {
  x^2
}

square(4)

----
Если return() не указан, возвращается последнее вычисленное выражение.
```
4. Векторизованные функции семейства apply
```
Функции семейства apply позволяют избегать явных циклов и работать с массивами и списками.

Основные функции семейства apply:
Функция-Назначение
apply()-Применение функции к строкам/столбцам
lapply()-Возвращает список
sapply()-Упрощает результат
vapply()-Строго типизированный вариант
tapply()-Применение по группам
mapply()-Многомерное применение
```

**Вопросы для поиска и письменного ответа**
1. Особенности языка программирования R
```
R — это интерпретируемый язык программирования и среда для статистических вычислений, анализа данных и визуализации.
Основные особенности R:
Векторная модель вычислений (операции сразу над массивами данных)
Интерпретируемый язык (не требует компиляции)
Поддержка нескольких парадигм
процедурное программирование
функциональное программирование
объектно-ориентированное программирование (S3, S4, R6)
Богатые средства статистического анализа
Мощные инструменты визуализации данных
Расширяемость за счёт пакетов
Открытый исходный код (open source)
R ориентирован прежде всего на работу с данными, а не на системное программирование.
```
2. Языки, поддерживающие парадигму векторизации
```
Векторизация — это парадигма, при которой операции выполняются над наборами данных, а не над отдельными элементами.
Языки с поддержкой векторизации:
Язык	Особенности
R	Полная векторизация по умолчанию
MATLAB	Матрично-ориентированный язык
Python (NumPy)	Векторизация через библиотеки
Julia	Высокопроизводительная векторизация
APL	Один из первых векторных языков
Fortran	Поддержка массивных операций
SAS	Аналитические и статистические вычисления

 В R векторизация является ключевой концепцией языка.
```
3. CRAN
```
CRAN (Comprehensive R Archive Network) — это глобальная сеть серверов, содержащая:
дистрибутивы языка R
пакеты расширений
документацию и руководства
Назначение CRAN:
централизованное хранилище пакетов
стандарты качества и совместимости
автоматическая установка и обновление пакетов

Пример установки пакета из CRAN:
install.packages("ggplot2")

Особенности CRAN:
строгая проверка пакетов
бесплатный доступ
тысячи пакетов для анализа данных, машинного обучения, визуализации
```
4. Плюсы и минусы языка R
```
Преимущества языка R:
Отлично подходит для статистики и анализа данных
Высокая степень векторизации
Большое сообщество и множество пакетов
Качественная визуализация
Бесплатный и кроссплатформенный
Активно используется в науке и образовании
Недостатки языка R:
Низкая производительность в циклах
Высокое потребление памяти
Менее удобен для разработки крупных приложений
Крутая кривая обучения для новичков
Ограниченные возможности для системного программирования
Краткий вывод
R — специализированный язык для анализа данных
Его ключевая особенность — векторизация
CRAN обеспечивает развитие и расширяемость R
R имеет как сильные стороны, так и ограничения
```
---
    
### 5. Функциональное программирование
**Задача:** Используя тестовые данные пакета repurrrsive выполните следующее 
задание. Создайте именованный список аналогичный по структуре списку sw_films, для 
установления имени полезно использовать функцию set_names пакета purrr. В качестве имени 
элементов списка необходимо использовать соответствующие название фильмов (обратите 
внимание, что обращаться к элементам списка можно используя как индекс, так и название 
элемента). Выполните задание в функциональном стиле.
```r
if (!require(repurrrsive)) install.packages("repurrrsive")
if (!require(purrr)) install.packages("purrr")
if (!require(tidyverse)) install.packages("tidyverse")

library(repurrrsive)
library(purrr)
library(tidyverse)

# Смотрим на структуру исходного списка sw_films
str(sw_films[1:2], max.level = 1)

# Создаем именованный список с названиями фильмов в качестве имен
named_sw_films <- sw_films %>% 
  set_names(map_chr(sw_films, "title"))

# Проверяем результат
str(named_sw_films[1:2], max.level = 1)
names(named_sw_films)
```
**Задача:** Используя документацию пакета purrr опишите отличия и особенности 
функций семейства map_*. Приведите примеры реализации с использование различных 
тестовых данных. Данные можно брать из пакета datasets или создав свои тестовые наборы. 
Для просмотра данных из пакета datasets выполните код library(help = "datasets") 
```r
# Загружаем необходимые пакеты
library(purrr)
library(datasets)

# Просматриваем доступные datasets
# library(help = "datasets")

cat("=== Функции семейства map_* в purrr ===\n\n")

# Создаем тестовые данные
test_list <- list(a = 1:5, b = 6:10, c = 11:15)
test_df <- data.frame(x = 1:5, y = 6:10, z = letters[1:5])
test_numeric <- c(1.5, 2.7, 3.2, 4.8, 5.1)
test_character <- c("apple", "banana", "cherry")
test_logical <- c(TRUE, FALSE, TRUE, TRUE, FALSE)

cat("1. map() - возвращает список:\n")
cat("   Применяет функцию к каждому элементу, возвращает список того же размера\n\n")

result_map <- map(test_list, ~ .x * 2)
print(result_map)

cat("\n2. map_lgl() - возвращает логический вектор:\n")
cat("   Функция должна возвращать логические значения\n\n")

result_lgl <- map_lgl(test_list, ~ mean(.x) > 5)
print(result_lgl)
```
Функциональное программирование emphasises использование функций высшего порядка, которые принимают другие функции как аргументы. Функция map_dbl() из пакета purrr применяет функцию mean() к каждому элементу списка и возвращает вектор результатов.


---

### 6. Грамотное программирование
**Задача:** Используя технологию R Markdown создайте динамический документ с 
произвольными расчетами. Документ должен содержать вставки кода по типу inline и в виде 
чанков. В документе должно быть использовано различное форматирование. Также для 
оформления используйте каскадную таблицу стилей.
```
films_df <- map_dfr(sw_films, ~{
  data.frame(
    Название = .x$title,
    Режиссер = .x$director,
    Продюсер = .x$producer,
    `Дата выхода` = .x$release_date,
    `Количество персонажей` = length(.x$characters),
    `Количество планет` = length(.x$planets),
    stringsAsFactors = FALSE
  )
})
```
Грамотное программирование объединяет код, результаты его выполнения и текстовые пояснения в одном документе. R Markdown позволяет создавать воспроизводимые отчеты, где код и его вывод интегрированы с текстовым описанием.

---

### 7. Параллельное программирование
**Задача:** Используя заранее подготовленные функции визуализируйте сведения о наиболее 
часто встречающихся словах из книг Джейн Остин по буквам английского алфавита. Книги, 
необходимые для анализа, находятся в пакете janeaustenr.

```r
# Загрузка необходимых пакетов
library(janeaustenr)
library(stringr)
library(purrr)

# Функции из задания
extract_words <- function(book_name) {
  text <- subset(austen_books(), book == book_name)$text
  str_extract_all(text, boundary("word")) %>% unlist %>% tolower
}

janeausten_words <- function() {
  books <- austen_books()$book %>% unique %>% as.character
  words <- sapply(books, extract_words) %>% unlist
  words
}

max_frequency <- function(letter, words, min_length = 1) {
  w <- select_words(letter, words = words, min_length = min_length)
  frequency <- table(w)
  frequency[which.max(frequency)]
}

select_words <- function(letter, words, min_length = 1) {
  min_length_words <- words[nchar(words) >= min_length]
  grep(paste0("^", letter), min_length_words, value = TRUE)
}
```
**Задача:** Распараллельте фрагмент кода, представленный ниже, используя вычислительный 
кластер:
```r
mean_of_rnorm <- function(n) {
  random_numbers <- rnorm(n)
  mean(random_numbers)
}

# Способ 1: Использование пакета parallel (базовый)
library(parallel)

# Создаем вычислительный кластер
cl <- makeCluster(detectCores() - 1) # Оставляем одно ядро свободным

# Экспортируем функцию в кластер
clusterExport(cl, "mean_of_rnorm")

# Распараллеленная версия
result_parallel <- parSapply(cl, seq_len(50), function(iter) {
  mean_of_rnorm(10000)
})

# Останавливаем кластер
stopCluster(cl)

# Выводим результаты
cat("Параллельные вычисления завершены\n")
cat("Среднее значение результатов:", mean(result_parallel), "\n")
cat("Стандартное отклонение результатов:", sd(result_parallel), "\n")
```
Параллельное программирование позволяет распределить вычисления между несколькими ядрами процессора. В этом примере мы создаем кластер из доступных ядер и используем функцию parSapply() для параллельного выполнения множества вычислений средних значений случайных чисел, что значительно ускоряет обработку.

---

## Выводы
В ходе работы изучены основные парадигмы программирования в R. Императивный подход демонстрирует последовательное выполнение команд. Структурный стиль организует код через ветвления и циклы. Объектно-ориентированное программирование реализовано через систему классов R6.

Векторная обработка позволяет работать с данными без циклов. Функциональный стиль использует функции высшего порядка. Грамотное программирование объединяет код и текст в R Markdown. Параллельные вычисления ускоряют обработку через многопоточность.

Каждая парадигма имеет свою область применения. Выбор подхода зависит от конкретной задачи. Изучение разных стилей программирования расширяет возможности эффективной работы в R.

---


